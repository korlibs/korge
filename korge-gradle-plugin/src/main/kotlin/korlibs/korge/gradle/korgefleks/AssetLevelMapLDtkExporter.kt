package korlibs.korge.gradle.korgefleks

import korlibs.korge.gradle.util.fromJson
import java.io.File

class AssetLevelMapLDtkExporter(
    private val assetDir: File,
    private val exportTilesDir: File,
    private val assetInfo: LinkedHashMap<String, Any>
) {
    var STACK_SIZE = 10  // Max number of stacked tiles per cell

    fun exportLevelMapLDtk(filename: String) {


        // Set input
//        val tilesetNames = listOf("tileset_planet_highlight", "tileset_planet_foreground", "tileset_planet_background")

        println("\nLDtk level parser started...")

        val ldtkFile = assetDir.resolve(filename)  // File("src/commonMain/resources/world_1/level_1/assets/level_1.ldtk")
        val ldtkJson = ldtkFile.readText().fromJson() as Map<String, Any?>

        val levelWidth: Int = ldtkJson["worldGridWidth"] as Int? ?: 0  // Level width in pixels
        val levelHeight = ldtkJson["worldGridHeight"] as Int? ?: 0     // Level height in pixels

        val ldtkLevels = ldtkJson["levels"] as List<Map<String, Any?>>    // Read all LDtk levels and store them
        val defs = ldtkJson["defs"] as Map<String, Any?>
        val jsonTileSets = defs["tilesets"] as List<Map<String, Any?>>

        // Check which tilesets are available
        // Load tags of tilesets and store tileset info into map for LEVEL (common) or SPECIAL (specific name)


        jsonTileSets.forEach { jsonTileSets ->
            println("Tileset found: '${jsonTileSets["identifier"]}' (Uid: '${jsonTileSets["uid"]}')")
        }
//            if (tileset != null) {
//                println("Tileset '$tilesetName' (Uid: '${tileset["uid"]}') found in LDtk file.")
//                val saveTileOffset = tileOffset
//                tileOffset += (tileset["__cWid"] as Int) * (tileset["__cHei"] as Int)
//                TileSetInfo(
//                    tileset["uid"] as Int,
//                    saveTileOffset,
//                    tileset["__cWid"] as Int,
//                    tileset["__cHei"] as Int,
//                    tileset["tileGridSize"] as Int
//                )
//            } else {
//                println("ERROR: Tileset '$tilesetName' not found in LDtk file!")
//                null
//            }
//        }.associateBy { it.uid }


        ldtkLevels.forEach { ldtkLevel ->
            val chunkName = ldtkLevel["identifier"]
            println("Processing '$chunkName' ...")

            // Create YAML string of an entity config from LDtk
            val yamlString = StringBuilder()
            yamlString.append("entities:\n")

            var gameObjectCnt = 0

            // Calculate level position in world grid
            val levelX: Int = ldtkLevel["worldX"] as Int / levelWidth
            val levelY: Int = ldtkLevel["worldY"] as Int / levelHeight
            val levelHeight = ldtkLevel["pxHei"] as Int  // Level height in pixels
            val levelWidth = ldtkLevel["pxWid"] as Int   // Level width in pixels
            val ldtkLevels = ldtkLevel["layerInstances"] as List<Map<String, Any?>>

            // Create stacked tile map data array (width * height) with max 10 stacked tiles per cell
            // TODO remove hardcoded size
            val stackedTileMapData: List<MutableList<Int>> = List(64 * 64) { MutableList(STACK_SIZE) { 0 } }


            ldtkLevels.forEach { ldtkLayer ->
                val layerName = ldtkLayer["__identifier"] as String
                val layerGridWidth = ldtkLayer["__cWid"] as Int  // Layer width in grid cells
                //val layerGridHeight = ldtkLayer["__cHei"] as Int  // Layer height in grid cells
                val tileSize = ldtkLayer["__gridSize"] as Int

                print("  Layer: '$layerName' ... ")


                val tilesetDefUid = ldtkLayer["__tilesetDefUid"] as Int?

                // Store tiles into stacked tile map data array

                // Check for each layer which tileset it uses
            //
            // and map tiles accordingly

/*
                if (tilesetDefUid != null && tileSets.containsKey(tilesetDefUid)) {
                    /**
                     * An array containing all tiles generated by Auto-layer rules. The array is already sorted
                     * in display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).<br/><br/>
                     * Note: if multiple tiles are stacked in the same cell as the result of different rules,
                     * all tiles behind opaque ones will be discarded.
                     */
                    val autoLayerTiles = ldtkLayer["autoLayerTiles"] as List<Map<String, Any?>>
                    stackTilesIntoTileMap(
                        autoLayerTiles,
                        stackedTileMapData,
                        layerGridWidth,
                        tileSize
                    )  // TODO - cleanup ldtkWorld.tilesetDefsById[ldtkLayer.tilesetDefUid]!!)

                    // Write stacked tile map data to YAML
                    // TODO
                    println("stacked tile map with ${autoLayerTiles.size} tiles processed.")
                }
*/
            }
        }


    }

}

object KorgeFleksAssets {

    data class TileSetInfo(
        val uid: Int,
        val tileOffset: Int,
        val width: Int,
        val height: Int,
        val tileSize: Int
    )

    private const val STACK_SIZE = 10  // Max number of stacked tiles per cell
    // Because we are stacking tiles from multiple tilesets we need to keep track of the tile offset for each tileset
    private var tileOffset = 0  // Tile offset helper - increases with each tileset processed

    fun parseLDtkLevel() {

        // Set input
        val tilesetNames = listOf("tileset_planet_highlight", "tileset_planet_foreground", "tileset_planet_background")

        println("\nLDtk level parser started...")

        val ldtkFile = File("src/commonMain/resources/world_1/level_1/assets/level_1.ldtk")
        val ldtkJson = ldtkFile.readText().fromJson() as Map<String, Any?>

        val levelWidth: Int = ldtkJson["worldGridWidth"] as Int? ?: 0  // Level width in pixels
        val levelHeight = ldtkJson["worldGridHeight"] as Int? ?: 0     // Level height in pixels
        val ldtkLevels = ldtkJson["levels"] as List<Map<String, Any?>>    // Read all LDtk levels and store them
        val defs = ldtkJson["defs"] as Map<String, Any?>
        val jsonTileSets = defs["tilesets"] as List<Map<String, Any?>>

        val tileSets: Map<Int, TileSetInfo> = tilesetNames.mapNotNull { tilesetName ->
            val tileset = jsonTileSets.firstOrNull { it["identifier"] == tilesetName }
            if (tileset != null) {
                println("Tileset '$tilesetName' (Uid: '${tileset["uid"]}') found in LDtk file.")
                val saveTileOffset = tileOffset
                tileOffset += (tileset["__cWid"] as Int) * (tileset["__cHei"] as Int)
                TileSetInfo(
                    tileset["uid"] as Int,
                    saveTileOffset,
                    tileset["__cWid"] as Int,
                    tileset["__cHei"] as Int,
                    tileset["tileGridSize"] as Int
                )
            } else {
                println("ERROR: Tileset '$tilesetName' not found in LDtk file!")
                null
            }
        }.associateBy { it.uid }

        ldtkLevels.forEach { ldtkLevel ->
            val chunkName = ldtkLevel["identifier"]
            println("Processing '$chunkName' ...")

            // Create YAML string of an entity config from LDtk
            val yamlString = StringBuilder()
            yamlString.append("entities:\n")

            var gameObjectCnt = 0

            // Calculate level position in world grid
            val levelX: Int = ldtkLevel["worldX"] as Int / levelWidth
            val levelY: Int = ldtkLevel["worldY"] as Int / levelHeight
            val levelHeight = ldtkLevel["pxHei"] as Int  // Level height in pixels
            val levelWidth = ldtkLevel["pxWid"] as Int   // Level width in pixels
            val ldtkLevels = ldtkLevel["layerInstances"] as List<Map<String, Any?>>

            // Create stacked tile map data array (width * height) with max 10 stacked tiles per cell
            // TODO remove hardcoded size
            val stackedTileMapData: List<MutableList<Int>> = List(64 * 64) { MutableList(STACK_SIZE) { 0 } }


            ldtkLevels.forEach { ldtkLayer ->
                val layerName = ldtkLayer["__identifier"] as String
                val layerGridWidth = ldtkLayer["__cWid"] as Int  // Layer width in grid cells
                //val layerGridHeight = ldtkLayer["__cHei"] as Int  // Layer height in grid cells
                val tileSize = ldtkLayer["__gridSize"] as Int

                print("  Layer: '$layerName' ... ")


                val tilesetDefUid = ldtkLayer["__tilesetDefUid"] as Int?

                // Store tiles into stacked tile map data array
                if (tilesetDefUid != null && tileSets.containsKey(tilesetDefUid)) {
                    /**
                     * An array containing all tiles generated by Auto-layer rules. The array is already sorted
                     * in display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).<br/><br/>
                     * Note: if multiple tiles are stacked in the same cell as the result of different rules,
                     * all tiles behind opaque ones will be discarded.
                     */
                    val autoLayerTiles = ldtkLayer["autoLayerTiles"] as List<Map<String, Any?>>
                    stackTilesIntoTileMap(autoLayerTiles, stackedTileMapData, layerGridWidth, tileSize)  // TODO - cleanup ldtkWorld.tilesetDefsById[ldtkLayer.tilesetDefUid]!!)

                    // Write stacked tile map data to YAML
                    // TODO
                    println("stacked tile map with ${autoLayerTiles.size} tiles processed.")
                }

                // Put all entity configs into one yaml file per chunk as list with local game object counter
                (ldtkLayer["entityInstances"] as List<Map<String, Any?>>).forEach { ldtkEntity ->
                    val entityName = ldtkEntity["__identifier"]

                    // Load all entity configs by first checking if field 'entityConfig' exists
                    val ldtkEntities = ldtkEntity["fieldInstances"] as List<Map<String, Any?>>
                    if (ldtkEntities.firstOrNull { it["__identifier"] == "entityConfig" } != null) {
                        val gameObjectName = if ((ldtkEntity["__tags"] as List<String>).firstOrNull { it == "unique" } != null) {
                            // Add scripts without unique count value - they are unique by name because they exist only once
                            entityName
                        } else {
                            // Add other game objects with a unique name as identifier
                            "${chunkName}_${entityName}_${gameObjectCnt++}"
                        }
                        yamlString.append("- name: ${gameObjectName}\n")
                        // Add entity config type
                        val entityConfigField = ldtkEntities.first { it["__identifier"] == "entityConfig" }
                        yamlString.append("  entityConfig: ${entityConfigField["__value"]}\n")

                        // Add position of entity = (chunk position in the level) + (position within the chunk) + (pivot point)
                        val entityPosX: Int = (ldtkEntity["px"] as List<Int>)[0] + (levelWidth * levelX)  // x position in pixels
                        val entityPosY: Int = (ldtkEntity["px"] as List<Int>)[1] + (levelHeight * levelY) // y position pixels
                        val entityPivotX: Float = (ldtkEntity["__pivot"] as List<Float>)[0]               // pivot within entity width/height [0..1]
                        val entityPivotY: Float = (ldtkEntity["__pivot"] as List<Float>)[1]

                        // Add position of entity
                        (ldtkEntity["__tags"] as List<String>).firstOrNull { it == "positionable" }?.let {
                            yamlString.append("  x: $entityPosX\n")
                            yamlString.append("  y: $entityPosY\n")
                            yamlString.append("  anchorX: ${entityPivotX * ldtkEntity["width"] as Int}\n")
                            yamlString.append("  anchorY: ${entityPivotY * ldtkEntity["height"] as Int}\n")
                        }

                        // Add all other fields of entity
                        ldtkEntities.forEach { field ->
                            if (field["__identifier"] != "entityConfig") yamlString.append("  ${field["__identifier"]}: ${field["__value"]}\n")
                        }
                        println("INFO: Game object '${ldtkEntity["__identifier"]}' loaded for '$chunkName'")
                        /*
                                                try {
                                                    // By deserializing the YAML string we get an EntityConfig object which itself registers in the EntityFactory
                                                    val entityConfig: EntityConfig =
                                                        assetStore.loader.configSerializer.yaml().decodeFromString(yamlString.toString())

                                                    // We need to store only the name of the entity config for later dynamically spawning of entities
                                                    if (entity.tags.firstOrNull { it == "unique" } == null) {
                                                        // Do not add unique entities to the list of entities - they are spawn separately
                                                        entities.add(entityConfig.name)
                                                    }
                                                    //println("INFO: Registering entity config '${entity.identifier}' for '$levelName'")
                                                } catch (e: Throwable) {
                                                    println("ERROR: Loading entity config - $e")
                                                }

                        */

                    } else println("ERROR: Game object with name '${entityName}' has no field 'entityConfig'!")
                }
            }
//            println("\n$yamlString")

            val yamlLevelMapString = StringBuilder()
            yamlLevelMapString.append("tileMap:\n- ")
            stackedTileMapData.forEachIndexed { idx, stackedTiles ->
                if (idx != 0) yamlLevelMapString.append(",")
                for ((idx, tile) in stackedTiles.withIndex()) {
                    if (idx == 0) yamlLevelMapString.append("[${tile}")
                    else if (tile != 0) yamlLevelMapString.append(",${tile}")
                }
                yamlLevelMapString.append("]")
            }

            val entityYamlFile = File("src/commonMain/resources/world_1/level_1/assets/level_data/${chunkName}.yaml")
            entityYamlFile.parentFile?.let { parent ->
                if (!parent.exists() && !parent.mkdirs()) error("Failed to create directory: ${parent.path}")
                entityYamlFile.writeText(yamlString.toString())
                entityYamlFile.appendText(yamlLevelMapString.toString())
            }
        }
    }

    private fun stackTilesIntoTileMap(autoLayerTiles: List<Map<String, Any?>>, stackedTileMapData: List<MutableList<Int>>, width: Int, tileSize: Int) {  //, tilesetDef: Map<String, Any?>) {
        for (tile in autoLayerTiles) {
            val (px, py) = tile["px"] as List<Int>  // Tile x, y position in layer
            val x = px / tileSize
            val y = py / tileSize
            val dx = px % tileSize
            val dy = py % tileSize
            val tileId = tile["t"] as Int // Tile id in the tileset which identifies the tile graphic
            //val flipX = (tile["f"] as Int).hasBitSet(0)
            //val flipY = (tile["f"] as Int).hasBitSet(1)

            if ((dx != 0 || dy != 0)) {
                println("WARNING: Tile at pixel position ($px,$py) is not aligned to tile size $tileSize (dx=$dx, dy=$dy)! This is currently not supported and tile offset will be ignored!")
            }

            val tileIndex = x + y * width
            val stackedTile = stackedTileMapData[tileIndex]

            for ((idx, tile) in stackedTile.withIndex()) {
                if (tile == 0) {
                    // Empty tile found, stack tile here
                    if (idx < STACK_SIZE) stackedTileMapData[tileIndex][idx] = tileId
                    else println("ERROR: Stack size exceeded at position ($x,$y)! Max stack size is $STACK_SIZE tiles per cell.")
                    break
                }
            }
        }
    }
}

/** Check if a specific bit at [index] is set */
fun Int.hasBitSet(index: Int): Boolean = ((this ushr index) and 1) != 0
