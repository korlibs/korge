// @WARNING: File AUTOGENERATED by `korlibs-generator-jvm/src/com/soywiz/korlibs` @ korlibs/kmem do not modify manually!
@file:Suppress("NOTHING_TO_INLINE", "EXTENSION_SHADOWED_BY_MEMBER", "RedundantUnitReturnType", "FunctionName")
package com.soywiz.kmem

import kotlin.js.JsName

public expect class MemBuffer
public expect fun MemBufferAlloc(size: Int): MemBuffer
public expect fun MemBufferAllocNoDirect(size: Int): MemBuffer
public expect fun MemBufferWrap(array: ByteArray): MemBuffer
public expect val MemBuffer.size: Int

public expect fun MemBuffer._sliceInt8Buffer(offset: Int, size: Int): Int8Buffer
public expect fun MemBuffer._sliceInt16Buffer(offset: Int, size: Int): Int16Buffer
public expect fun MemBuffer._sliceInt32Buffer(offset: Int, size: Int): Int32Buffer
public expect fun MemBuffer._sliceFloat32Buffer(offset: Int, size: Int): Float32Buffer
public expect fun MemBuffer._sliceFloat64Buffer(offset: Int, size: Int): Float64Buffer

public fun MemBuffer.sliceInt8Buffer(offset: Int = 0, size: Int = (this.size / 1) - offset): Int8Buffer = this._sliceInt8Buffer(offset, size)
public fun MemBuffer.sliceInt16Buffer(offset: Int = 0, size: Int = (this.size / 2) - offset): Int16Buffer = this._sliceInt16Buffer(offset, size)
public fun MemBuffer.sliceInt32Buffer(offset: Int = 0, size: Int = (this.size / 4) - offset): Int32Buffer = this._sliceInt32Buffer(offset, size)
public fun MemBuffer.sliceFloat32Buffer(offset: Int = 0, size: Int = (this.size / 4) - offset): Float32Buffer = this._sliceFloat32Buffer(offset, size)
public fun MemBuffer.sliceFloat64Buffer(offset: Int = 0, size: Int = (this.size / 8) - offset): Float64Buffer = this._sliceFloat64Buffer(offset, size)
public fun MemBuffer.sliceUint8Buffer(offset: Int = 0, size: Int = (this.size / 2) - offset): Uint8Buffer = Uint8Buffer(_sliceInt8Buffer(offset, size))
public fun MemBuffer.sliceUint16Buffer(offset: Int = 0, size: Int = (this.size / 2) - offset): Uint16Buffer = Uint16Buffer(_sliceInt16Buffer(offset, size))

public fun MemBuffer.sliceInt8BufferByteOffset(byteOffset: Int = 0, size: Int = (this.size / 1) - byteOffset / 1): Int8Buffer = this._sliceInt8Buffer(byteOffset / 1, size)
public fun MemBuffer.sliceInt16BufferByteOffset(byteOffset: Int = 0, size: Int = (this.size / 2) - byteOffset / 2): Int16Buffer = this._sliceInt16Buffer(byteOffset / 2, size)
public fun MemBuffer.sliceInt32BufferByteOffset(byteOffset: Int = 0, size: Int = (this.size / 4) - byteOffset / 4): Int32Buffer = this._sliceInt32Buffer(byteOffset / 4, size)
public fun MemBuffer.sliceFloat32BufferByteOffset(byteOffset: Int = 0, size: Int = (this.size / 4) - byteOffset / 4): Float32Buffer = this._sliceFloat32Buffer(byteOffset / 4, size)
public fun MemBuffer.sliceFloat64BufferByteOffset(byteOffset: Int = 0, size: Int = (this.size / 8) - byteOffset / 8): Float64Buffer = this._sliceFloat64Buffer(byteOffset / 8, size)
public fun MemBuffer.sliceUint8BufferByteOffset(byteOffset: Int = 0, size: Int = (this.size / 2) - byteOffset / 2): Uint8Buffer = Uint8Buffer(_sliceInt8Buffer(byteOffset / 2, size))
public fun MemBuffer.sliceUint16BufferByteOffset(byteOffset: Int = 0, size: Int = (this.size / 2) - byteOffset / 2): Uint16Buffer = Uint16Buffer(_sliceInt16Buffer(byteOffset / 2, size))

public fun MemBuffer.asInt8Buffer(): Int8Buffer = this.sliceInt8Buffer()
public fun MemBuffer.asInt16Buffer(): Int16Buffer = this.sliceInt16Buffer()
public fun MemBuffer.asInt32Buffer(): Int32Buffer = this.sliceInt32Buffer()
public fun MemBuffer.asFloat32Buffer(): Float32Buffer = this.sliceFloat32Buffer()
public fun MemBuffer.asFloat64Buffer(): Float64Buffer = this.sliceFloat64Buffer()

public fun NewFast32Buffer(size: Int): Fast32Buffer = NewFast32Buffer(MemBufferAllocNoDirect(size * 4))

// @TODO: abstract/inline on ByteBuffer (JVM), but non-abstract on ByteArray (native) and a wrapper class on JS
public expect abstract class Fast32Buffer
public expect fun NewFast32Buffer(mem: MemBuffer): Fast32Buffer
public expect val Fast32Buffer.length: Int
public expect inline fun Fast32Buffer.getF(index: Int): Float
public expect inline fun Fast32Buffer.setF(index: Int, value: Float)
public expect inline fun Fast32Buffer.getI(index: Int): Int
public expect inline fun Fast32Buffer.setI(index: Int, value: Int)

public expect class DataBuffer
public expect fun MemBuffer.getData(): DataBuffer
public expect val DataBuffer.mem: MemBuffer
public expect fun DataBuffer.getByte(index: Int): Byte
public expect fun DataBuffer.setByte(index: Int, value: Byte): Unit
public expect fun DataBuffer.getShort(index: Int): Short
public expect fun DataBuffer.setShort(index: Int, value: Short): Unit
public expect fun DataBuffer.getInt(index: Int): Int
public expect fun DataBuffer.setInt(index: Int, value: Int): Unit
public expect fun DataBuffer.getFloat(index: Int): Float
public expect fun DataBuffer.setFloat(index: Int, value: Float): Unit
public expect fun DataBuffer.getDouble(index: Int): Double
public expect fun DataBuffer.setDouble(index: Int, value: Double): Unit

// @TODO: imul is super slow on Kotlin/JS. Why is that? Can't use Math.imul?
//function imul(a_local, b_local) {
//    var lhs = jsBitwiseAnd(a_local, 4.29490176E9) * jsBitwiseAnd(b_local, 65535);
//    var rhs = jsBitwiseAnd(a_local, 65535) * b_local;
//    return jsBitwiseOr(lhs + rhs, 0);
//}
public fun DataBuffer.setAlignedByte(index: Int, value: Byte): Unit = setByte(index, value)
public fun DataBuffer.setAlignedShort(index: Int, value: Short): Unit = setShort(index shl 1, value)
public fun DataBuffer.setAlignedInt(index: Int, value: Int): Unit = setInt(index shl 2, value)
public fun DataBuffer.setAlignedFloat(index: Int, value: Float): Unit = setFloat(index shl 2, value)

public fun DataBuffer.getAlignedByte(index: Int): Byte = getByte(index)
public fun DataBuffer.getAlignedShort(index: Int): Short = getShort(index shl 1)
public fun DataBuffer.getAlignedInt(index: Int): Int = getInt(index shl 2)
public fun DataBuffer.getAlignedFloat(index: Int): Float = getFloat(index shl 2)

public expect class Int8Buffer
@Deprecated("", ReplaceWith("Int8BufferAlloc(size)"))
public inline fun Int8BufferAlloc(size: Int): Int8Buffer = Int8Buffer(size)
@JsName("NewInt8Buffer")
public inline fun Int8Buffer(size: Int, dummy: Unit = Unit): Int8Buffer = MemBufferAlloc(size * 1).sliceInt8Buffer()
public expect val Int8Buffer.mem: MemBuffer
public expect val Int8Buffer.offset: Int
public expect val Int8Buffer.size: Int
public expect operator fun Int8Buffer.get(index: Int): Byte
public expect operator fun Int8Buffer.set(index: Int, value: Byte): Unit
public fun Int8Buffer.subarray(begin: Int, end: Int = this.size): Int8Buffer = this.mem.sliceInt8Buffer(this.offset + begin, end - begin)

public expect class Int16Buffer
@Deprecated("", ReplaceWith("Int16Buffer(size)"))
public inline fun Int16BufferAlloc(size: Int): Int16Buffer = Int16Buffer(size)
@JsName("NewInt16Buffer")
public inline fun Int16Buffer(size: Int, dummy: Unit = Unit): Int16Buffer = MemBufferAlloc(size * 2).sliceInt16Buffer()
public expect val Int16Buffer.mem: MemBuffer
public expect val Int16Buffer.offset: Int
public expect val Int16Buffer.size: Int
public expect operator fun Int16Buffer.get(index: Int): Short
public expect operator fun Int16Buffer.set(index: Int, value: Short): Unit
public fun Int16Buffer.subarray(begin: Int, end: Int = this.size): Int16Buffer = this.mem.sliceInt16Buffer(this.offset + begin, end - begin)

public expect class Int32Buffer
@Deprecated("", ReplaceWith("Int32Buffer(size)"))
public inline fun Int32BufferAlloc(size: Int): Int32Buffer = Int32Buffer(size)
@JsName("NewInt32Buffer")
public inline fun Int32Buffer(size: Int, dummy: Unit = Unit): Int32Buffer = MemBufferAlloc(size * 4).sliceInt32Buffer()
public expect val Int32Buffer.mem: MemBuffer
public expect val Int32Buffer.offset: Int
public expect val Int32Buffer.size: Int
public expect operator fun Int32Buffer.get(index: Int): Int
public expect operator fun Int32Buffer.set(index: Int, value: Int): Unit
public fun Int32Buffer.subarray(begin: Int, end: Int = this.size): Int32Buffer = this.mem.sliceInt32Buffer(this.offset + begin, end - begin)

public expect class Float32Buffer
@Deprecated("", ReplaceWith("Float32Buffer(size)"))
public inline fun Float32BufferAlloc(size: Int): Float32Buffer = Float32Buffer(size)
@JsName("NewFloat32Buffer")
public inline fun Float32Buffer(size: Int, dummy: Unit = Unit): Float32Buffer = MemBufferAlloc(size * 4).sliceFloat32Buffer()
public expect val Float32Buffer.mem: MemBuffer
public expect val Float32Buffer.offset: Int
public expect val Float32Buffer.size: Int
public expect operator fun Float32Buffer.get(index: Int): Float
public expect operator fun Float32Buffer.set(index: Int, value: Float): Unit
public fun Float32Buffer.subarray(begin: Int, end: Int = this.size): Float32Buffer = this.mem.sliceFloat32Buffer(this.offset + begin, end - begin)

public expect class Float64Buffer
@Deprecated("", ReplaceWith("Float64Buffer(size)"))
public inline fun Float64BufferAlloc(size: Int): Float64Buffer = Float64Buffer(size)
@JsName("NewFloat64Buffer")
public inline fun Float64Buffer(size: Int, dummy: Unit = Unit): Float64Buffer = MemBufferAlloc(size * 8).sliceFloat64Buffer()
public expect val Float64Buffer.mem: MemBuffer
public expect val Float64Buffer.offset: Int
public expect val Float64Buffer.size: Int
public expect operator fun Float64Buffer.get(index: Int): Double
public expect operator fun Float64Buffer.set(index: Int, value: Double): Unit
public fun Float64Buffer.subarray(begin: Int, end: Int = this.size): Float64Buffer = this.mem.sliceFloat64Buffer(this.offset + begin, end - begin)

/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Int8Buffer, srcPos: Int, dst: Int8Buffer, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos) * 1, dst.mem, (dst.offset + dstPos) * 1, size * 1)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: ByteArray, srcPos: Int, dst: Int8Buffer, dstPos: Int, size: Int): Unit = arraycopy(src, srcPos, dst.mem, (dst.offset + dstPos), size)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Int8Buffer, srcPos: Int, dst: ByteArray, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos), dst, dstPos, size)

/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Int16Buffer, srcPos: Int, dst: Int16Buffer, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos) * 2, dst.mem, (dst.offset + dstPos) * 2, size * 2)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: ShortArray, srcPos: Int, dst: Int16Buffer, dstPos: Int, size: Int): Unit = arraycopy(src, srcPos, dst.mem, (dst.offset + dstPos), size)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Int16Buffer, srcPos: Int, dst: ShortArray, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos), dst, dstPos, size)

/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Int32Buffer, srcPos: Int, dst: Int32Buffer, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos) * 4, dst.mem, (dst.offset + dstPos) * 4, size * 4)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: IntArray, srcPos: Int, dst: Int32Buffer, dstPos: Int, size: Int): Unit = arraycopy(src, srcPos, dst.mem, (dst.offset + dstPos), size)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Int32Buffer, srcPos: Int, dst: IntArray, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos), dst, dstPos, size)

/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Float32Buffer, srcPos: Int, dst: Float32Buffer, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos) * 4, dst.mem, (dst.offset + dstPos) * 4, size * 4)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: FloatArray, srcPos: Int, dst: Float32Buffer, dstPos: Int, size: Int): Unit = arraycopy(src, srcPos, dst.mem, (dst.offset + dstPos), size)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Float32Buffer, srcPos: Int, dst: FloatArray, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos), dst, dstPos, size)

/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Float64Buffer, srcPos: Int, dst: Float64Buffer, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos) * 8, dst.mem, (dst.offset + dstPos) * 8, size * 8)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: DoubleArray, srcPos: Int, dst: Float64Buffer, dstPos: Int, size: Int): Unit = arraycopy(src, srcPos, dst.mem, (dst.offset + dstPos), size)
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public fun arraycopy(src: Float64Buffer, srcPos: Int, dst: DoubleArray, dstPos: Int, size: Int): Unit = arraycopy(src.mem, (src.offset + srcPos), dst, dstPos, size)

/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: MemBuffer, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: ByteArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: MemBuffer, srcPos: Int, dst: ByteArray, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: ShortArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: MemBuffer, srcPos: Int, dst: ShortArray, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: IntArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: MemBuffer, srcPos: Int, dst: IntArray, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: FloatArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: MemBuffer, srcPos: Int, dst: FloatArray, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: DoubleArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit
/** Copies [size] elements of [src] starting at [srcPos] into [dst] at [dstPos]  */
public expect fun arraycopy(src: MemBuffer, srcPos: Int, dst: DoubleArray, dstPos: Int, size: Int): Unit

@Deprecated("", ReplaceWith("Int16Buffer(mem, offset, len)"))
public fun NewInt16Buffer(mem: MemBuffer, offset: Int, len: Int): Int16Buffer = com.soywiz.kmem.buffer.Int16Buffer(mem, offset, len)
@Deprecated("", ReplaceWith("Int32Buffer(mem, offset, len)"))
public fun NewInt32Buffer(mem: MemBuffer, offset: Int, len: Int): Int32Buffer = com.soywiz.kmem.buffer.Int32Buffer(mem, offset, len)
@Deprecated("", ReplaceWith("Float32Buffer(mem, offset, len)"))
public fun NewFloat32Buffer(mem: MemBuffer, offset: Int, len: Int): Float32Buffer = com.soywiz.kmem.buffer.Float32Buffer(mem, offset, len)
@Deprecated("", ReplaceWith("Float64Buffer(mem, offset, len)"))
public fun NewFloat64Buffer(mem: MemBuffer, offset: Int, len: Int): Float64Buffer = com.soywiz.kmem.buffer.Float64Buffer(mem, offset, len)

fun ByteArray.toMemBuffer(): MemBuffer = MemBufferWrap(this)
fun ByteArray.toInt8Buffer(): Int8Buffer = this.toMemBuffer().asInt8Buffer()
fun ByteArray.toUint8Buffer(): Uint8Buffer = Uint8Buffer(this.toInt8Buffer())
//val Uint8Buffer.bytes get() = this.b.mem.getData()

fun Int8Buffer(data: ByteArray): Int8Buffer {
    val out = Int8Buffer(data.size)
    for (n in data.indices) out[n] = data[n]
    return out
}

fun Int16Buffer(data: ShortArray): Int16Buffer {
    val out = Int16Buffer(data.size)
    for (n in data.indices) out[n] = data[n]
    return out
}

fun Int32Buffer(data: IntArray): Int32Buffer {
    val out = Int32Buffer(data.size)
    for (n in data.indices) out[n] = data[n]
    return out
}

fun Float32Buffer(data: FloatArray): Float32Buffer {
    val out = Float32Buffer(data.size)
    for (n in data.indices) out[n] = data[n]
    return out
}

fun Float64Buffer(data: DoubleArray): Float64Buffer {
    val out = Float64Buffer(data.size)
    for (n in data.indices) out[n] = data[n]
    return out
}
