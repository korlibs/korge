// @WARNING: File AUTOGENERATED by `korlibs-generator-jvm/src/com/soywiz/korlibs` @ korlibs/kmem do not modify manually!
// @TODO: USELESS_CAST is required since it requires a cast to work, but IDE says that that cast is not necessary
@file:Suppress("NOTHING_TO_INLINE", "EXTENSION_SHADOWED_BY_MEMBER", "RedundantUnitReturnType", "FunctionName", "USELESS_CAST")
package com.soywiz.kmem

import java.nio.Buffer
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.DoubleBuffer
import java.nio.FloatBuffer
import java.nio.IntBuffer
import java.nio.ShortBuffer

@PublishedApi
internal fun java.nio.Buffer.checkSliceBounds(offset: Int, size: Int) {
	//val end = offset + size - 1
	//if (offset !in 0 until this.capacity()) error("offset=$offset, size=$size not inside ${this.capacity()}")
	//if (end !in 0 until this.capacity()) error("offset=$offset, size=$size not inside ${this.capacity()}")
}

inline fun <T : Buffer> T._slice(offset: Int, size: Int, dup: (T) -> T): T {
    checkSliceBounds(offset, size)
    val out = dup(this)
    val start = this.position() + offset
    val end = start + size
    out.positionSafe(start)
    out.limitSafe(end)
    return out
}

fun ByteBuffer.slice(offset: Int, size: Int): ByteBuffer = _slice(offset, size) { it.duplicate() }
fun ShortBuffer.slice(offset: Int, size: Int): ShortBuffer = _slice(offset, size) { it.duplicate() }
fun IntBuffer.slice(offset: Int, size: Int): IntBuffer = _slice(offset, size) { it.duplicate() }
fun FloatBuffer.slice(offset: Int, size: Int): FloatBuffer = _slice(offset, size) { it.duplicate() }
fun DoubleBuffer.slice(offset: Int, size: Int): DoubleBuffer = _slice(offset, size) { it.duplicate() }
public actual class MemBuffer(val buffer: ByteBuffer, val size: Int) {
    val sbuffer = buffer.order(ByteOrder.nativeOrder()).asShortBuffer()
    val ibuffer = buffer.order(ByteOrder.nativeOrder()).asIntBuffer()
    val fbuffer = buffer.order(ByteOrder.nativeOrder()).asFloatBuffer()
    val dbuffer = buffer.order(ByteOrder.nativeOrder()).asDoubleBuffer()
}
public actual fun MemBufferAlloc(size: Int): MemBuffer = MemBuffer(ByteBuffer.allocateDirect(size).order(ByteOrder.nativeOrder()), size)
public actual fun MemBufferAllocNoDirect(size: Int): MemBuffer = MemBuffer(ByteBuffer.allocate(size).order(ByteOrder.nativeOrder()), size)
public actual fun MemBufferWrap(array: ByteArray): MemBuffer = MemBuffer(ByteBuffer.wrap(array).order(ByteOrder.nativeOrder()), array.size)
public actual inline val MemBuffer.size: Int get() = this.size

public actual fun MemBuffer._sliceInt8Buffer(offset: Int, size: Int): Int8Buffer = Int8Buffer(this, this.buffer.slice(offset, size))
public actual fun MemBuffer._sliceInt16Buffer(offset: Int, size: Int): Int16Buffer = Int16Buffer(this, this.buffer.asShortBuffer().slice(offset, size))
public actual fun MemBuffer._sliceInt32Buffer(offset: Int, size: Int): Int32Buffer = Int32Buffer(this, this.buffer.asIntBuffer().slice(offset, size))
public actual fun MemBuffer._sliceFloat32Buffer(offset: Int, size: Int): Float32Buffer = Float32Buffer(this, this.buffer.asFloatBuffer().slice(offset, size))
public actual fun MemBuffer._sliceFloat64Buffer(offset: Int, size: Int): Float64Buffer = Float64Buffer(this, this.buffer.asDoubleBuffer().slice(offset, size))

public actual typealias DataBuffer = MemBuffer
public actual val DataBuffer.mem: MemBuffer get() = this
public actual fun MemBuffer.getData(): DataBuffer = this
public actual fun DataBuffer.getByte(index: Int): Byte = buffer.get(index)
public actual fun DataBuffer.setByte(index: Int, value: Byte) { buffer.put(index, value) }
public actual fun DataBuffer.getShort(index: Int): Short = buffer.getShort(index)
public actual fun DataBuffer.setShort(index: Int, value: Short) { buffer.putShort(index, value) }
public actual fun DataBuffer.getInt(index: Int): Int = buffer.getInt(index)
public actual fun DataBuffer.setInt(index: Int, value: Int) { buffer.putInt(index, value) }
public actual fun DataBuffer.getFloat(index: Int): Float = buffer.getFloat(index)
public actual fun DataBuffer.setFloat(index: Int, value: Float) { buffer.putFloat(index, value) }
public actual fun DataBuffer.getDouble(index: Int): Double = buffer.getDouble(index)
public actual fun DataBuffer.setDouble(index: Int, value: Double) { buffer.putDouble(index, value) }

public actual class Int8Buffer(val mbuffer: MemBuffer, val jbuffer: ByteBuffer)

public actual val Int8Buffer.mem: MemBuffer get() = mbuffer
public actual val Int8Buffer.offset: Int get() = (jbuffer as java.nio.Buffer).position()
public actual val Int8Buffer.size: Int get() = (jbuffer as java.nio.Buffer).limit() - offset
public actual operator fun Int8Buffer.get(index: Int): Byte = jbuffer.get(offset + index)
public actual operator fun Int8Buffer.set(index: Int, value: Byte) { jbuffer.put(offset + index, value) }

public actual class Int16Buffer(val mbuffer: MemBuffer, val jbuffer: ShortBuffer)

public actual val Int16Buffer.mem: MemBuffer get() = mbuffer
public actual val Int16Buffer.offset: Int get() = (jbuffer as java.nio.Buffer).position()
public actual val Int16Buffer.size: Int get() = (jbuffer as java.nio.Buffer).limit() - offset
public actual operator fun Int16Buffer.get(index: Int): Short = jbuffer.get(offset + index)
public actual operator fun Int16Buffer.set(index: Int, value: Short) { jbuffer.put(offset + index, value) }

public actual class Int32Buffer(val mbuffer: MemBuffer, val jbuffer: IntBuffer)

public actual val Int32Buffer.mem: MemBuffer get() = mbuffer
public actual val Int32Buffer.offset: Int get() = (jbuffer as java.nio.Buffer).position()
public actual val Int32Buffer.size: Int get() = (jbuffer as java.nio.Buffer).limit() - offset
public actual operator fun Int32Buffer.get(index: Int): Int = jbuffer.get(offset + index)
public actual operator fun Int32Buffer.set(index: Int, value: Int) { jbuffer.put(offset + index, value) }

public actual class Float32Buffer(val mbuffer: MemBuffer, val jbuffer: FloatBuffer)

public actual val Float32Buffer.mem: MemBuffer get() = mbuffer
public actual val Float32Buffer.offset: Int get() = (jbuffer as java.nio.Buffer).position()
public actual val Float32Buffer.size: Int get() = (jbuffer as java.nio.Buffer).limit() - offset
public actual operator fun Float32Buffer.get(index: Int): Float = jbuffer.get(offset + index)
public actual operator fun Float32Buffer.set(index: Int, value: Float) { jbuffer.put(offset + index, value) }

public actual class Float64Buffer(val mbuffer: MemBuffer, val jbuffer: DoubleBuffer)

public actual val Float64Buffer.mem: MemBuffer get() = mbuffer
public actual val Float64Buffer.offset: Int get() = (jbuffer as java.nio.Buffer).position()
public actual val Float64Buffer.size: Int get() = (jbuffer as java.nio.Buffer).limit() - offset
public actual operator fun Float64Buffer.get(index: Int): Double = jbuffer.get(offset + index)
public actual operator fun Float64Buffer.set(index: Int, value: Double) { jbuffer.put(offset + index, value) }

inline operator fun ByteBuffer.set(index: Int, value: Byte) = this.put(index, value)
inline operator fun ShortBuffer.set(index: Int, value: Short) = this.put(index, value)
inline operator fun IntBuffer.set(index: Int, value: Int) = this.put(index, value)
inline operator fun FloatBuffer.set(index: Int, value: Float) = this.put(index, value)
inline operator fun DoubleBuffer.set(index: Int, value: Double) = this.put(index, value)
inline operator fun MemBuffer.set(index: Int, value: Byte) = this.buffer.put(index, value)
inline operator fun MemBuffer.get(index: Int): Byte = this.buffer.get(index)

inline fun <T> java.nio.Buffer.keepPositionLimit(block: () -> T): T {
    val oldPos = this.position()
    val oldLimit = this.limit()
    try {
        return block()
    } finally {
        this.limitSafe(oldLimit)
        this.positionSafe(oldPos)
    }
}

fun java.nio.Buffer.positionSafe(newPosition: Int): Unit { position(newPosition) }
fun java.nio.Buffer.limitSafe(newLimit: Int): Unit { limit(newLimit) }
fun java.nio.Buffer.clearSafe(): Unit { clear() }
fun java.nio.Buffer.flipSafe(): Unit { flip() }

private inline fun <T> arraycopy(size: Int, src: Any?, srcPos: Int, dst: Any?, dstPos: Int, setDst: (Int, T) -> Unit, getSrc: (Int) -> T) {
    val overlapping = src === dst && dstPos > srcPos
    if (overlapping) {
        var n = size
        while (--n >= 0) setDst(dstPos + n, getSrc(srcPos + n))
    } else {
        for (n in 0 until size) setDst(dstPos + n, getSrc(srcPos + n))
    }
}

public actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int) {
    val srcBuf = src.buffer
    val dstBuf = dst.buffer

    val overlapping = srcBuf === dstBuf && dstPos > srcPos
    if (overlapping) {
        arraycopy(size, srcBuf, srcPos, dstBuf, dstPos, { it, value -> dst[it] = value }, { src[it] })
        return
    }

    if (!srcBuf.isDirect && !dstBuf.isDirect) {
        System.arraycopy(srcBuf.array(), srcPos, dstBuf.array(), dstPos, size)
        return
    }

    dstBuf.keepPositionLimit {
        srcBuf.keepPositionLimit {
            dstBuf.positionSafe(dstPos)
            srcBuf.positionSafe(srcPos)
            srcBuf.limitSafe(size)
            dstBuf.put(srcBuf)
        }
    }
}
public actual fun arraycopy(src: ByteArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int) {
    val dstBuf = dst.buffer
    dstBuf.keepPositionLimit {
        dstBuf.positionSafe(dstPos)
        dstBuf.put(src, srcPos, size)
    }
}
public actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: ByteArray, dstPos: Int, size: Int) {
    val srcBuf = src.buffer
    srcBuf.keepPositionLimit {
        srcBuf.positionSafe(srcPos)
        srcBuf.get(dst, dstPos, size)
    }
    //arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst[it] = value }, { src[it] })
}
public actual fun arraycopy(src: ShortArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int) {
    arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst.sbuffer[it] = value }, { src[it] })
}
public actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: ShortArray, dstPos: Int, size: Int) {
    arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst[it] = value }, { src.sbuffer[it] })
}
public actual fun arraycopy(src: IntArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int) {
    arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst.ibuffer[it] = value }, { src[it] })
}
public actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: IntArray, dstPos: Int, size: Int) {
    arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst[it] = value }, { src.ibuffer[it] })
}
public actual fun arraycopy(src: FloatArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int) {
    arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst.fbuffer[it] = value }, { src[it] })
}
public actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: FloatArray, dstPos: Int, size: Int) {
    arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst[it] = value }, { src.fbuffer[it] })
}
public actual fun arraycopy(src: DoubleArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int) {
    arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst.dbuffer[it] = value }, { src[it] })
}
public actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: DoubleArray, dstPos: Int, size: Int) {
    arraycopy(size, src, srcPos, dst, dstPos, { it, value -> dst[it] = value }, { src.dbuffer[it] })
}
