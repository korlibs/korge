package korlibs.korge.view

import korlibs.datastructure.*
import korlibs.datastructure.iterators.*
import korlibs.event.*
import korlibs.io.lang.*
import korlibs.korge.internal.*
import korlibs.korge.render.*
import korlibs.korge.view.property.*
import korlibs.math.*
import korlibs.math.geom.*

/** Creates a new [Container], allowing to configure with [callback], and attaches the newly created container to the receiver this [Container] */
inline fun Container.container(cull: Boolean = false, callback: @ViewDslMarker Container.() -> Unit = {}) =
    Container(cull).addTo(this, callback)

// For Flash compatibility
//open class Sprite : Container()

/**
 * A simple container of [View]s.
 *
 * All the [children] in this container have an associated index that determines their rendering order.
 * The first child is rendered first, and the last one is rendered last. So when children are overlapping with each other,
 * the last child will overlap the previous ones.
 *
 * You can access the children by using the [children] collection, or the [numChildren], [getChildAt] and [get] properties.
 *
 * You can add new children to this container by calling [addChild] or [addChildAt].
 */
@OptIn(KorgeInternal::class)
open class Container(
    @property:ViewProperty
    var cull: Boolean = false
) : View(true) {
    private val __children: FastArrayList<View> = FastArrayList()

    /**
     * A collection with all the children [View]s.
     */
    val children: ContainerCollection = ContainerCollection(this, __children)

    @PublishedApi
    override val _children: List<View>? get() = __children

    private var __tempDispatchChildren: FastArrayList<View>? = null

    inline fun fastForEachChild(block: (child: View) -> Unit) {
        children.fastForEach { child -> block(child) }
    }

    //@KorgeInternal @PublishedApi internal val childrenInternal: FastArrayList<View> get() = __children!!

    override fun invalidate() {
        super.invalidate()
        fastForEachChild { child ->
            if (child._requireInvalidate) {
                child.invalidate()
            }
        }
    }

    override fun invalidateColorTransform() {
        super.invalidateColorTransform()
        fastForEachChild { child ->
            if (child._requireInvalidateColor) {
                child.invalidateColorTransform()
            }
        }
    }

    /** Returns the first child of this container or null when the container doesn't have children */
    val firstChild: View? get() = __children.firstOrNull()

    /** Returns the last child of this container or null when the container doesn't have children */
    val lastChild: View? get() = __children.lastOrNull()

    /** Sorts all the children by using the specified [comparator]. */
    fun sortChildrenBy(comparator: Comparator<View>) {
        __children.sortWith(comparator)
        forEachChildWithIndex { index: Int, child: View ->
            child.index = index
        }
        invalidateZIndexChildren()
    }

    /** Returns the number of children this container has */
    @Suppress("FoldInitializerAndIfToElvis")
    val numChildren: Int get() = __children.size

    /**
     * Recursively retrieves the top ancestor in the container hierarchy.
     *
     * Retrieves the top ancestor of the hierarchy. In case the container is orphan this very instance is returned.
     */
    val containerRoot: Container get() = parent?.containerRoot ?: this

    /**
     * Recursively retrieves the ancestor in the container hierarchy that is a [View.Reference] like the stage or null when can't be found.
     */
    val referenceParent: Container?
        get() {
            if (parent is Reference) return parent
            return parent?.referenceParent
        }

    /**
     * Swaps the order of two child [View]s [view1] and [view2].
     * If [view1] or [view2] are not part of this container, this method doesn't do anything.
     */
    @KorgeUntested
    fun swapChildren(view1: View, view2: View) {
        if (view1.parent != view2.parent || view1.parent != this) return
        invalidateZIndexChildren()
        val index1 = view1.index
        val index2 = view2.index
        __children[index1] = view2
        view2.index = index1
        __children[index2] = view1
        view1.index = index2
    }

    fun moveChildTo(view: View, index: Int) {
        if (view.parent != this) return
        val targetIndex = index.clamp(0, numChildren - 1)
        while (view.index < targetIndex) swapChildren(view, __children[view.index + 1])
        while (view.index > targetIndex) swapChildren(view, __children[view.index - 1])
    }

    fun sendChildToFront(view: View) {
        if (view.parent !== this) return
        while (view != lastChild!!) {
            swapChildren(view, children[view.index + 1])
        }
    }

    fun sendChildToBack(view: View) {
        if (view.parent !== this) return
        while (view != firstChild!!) {
            swapChildren(view, children[view.index - 1])
        }
    }

    protected open fun onChildAdded(view: View) {
    }

    open fun onChildChangedSize(view: View) {
    }

    override fun onAncestorChanged() {
        super.onAncestorChanged()
        forEachChild {
            //it.apply { KorgeInternalApi._onAncestorChanged() }
            it._onAncestorChanged()
        }
    }
    /**
     * Retrieves the index of a given child [View].
     */
    @KorgeUntested
    fun getChildIndex(view: View): Int = view.index

    /**
     * Finds the [View] at a given index.
     * Remarks: if [index] is outside bounds 0..[numChildren] - 1, an [IndexOutOfBoundsException] will be thrown.
     */
    fun getChildAt(index: Int): View = __children[index]

    /**
     * Finds the [View] at a given index. If the index is not valid, it returns null.
     */
    fun getChildAtOrNull(index: Int): View? = __children.getOrNull(index)

    /**
     * Finds the first child [View] matching a given [name].
     */
    @KorgeUntested
    fun getChildByName(name: String): View? = __children.firstOrNull { it.name == name }

    fun removeChildAt(index: Int): Boolean =
        removeChild(getChildAtOrNull(index))

    // @TODO: Optimize
    fun removeChildAt(index: Int, count: Int) {
        repeat(count) { removeChildAt(index) }
        invalidateZIndexChildren()
    }

    // @TODO: Optimize
    fun swapChildrenAt(indexA: Int, indexB: Int) {
        val a = getChildAtOrNull(indexA) ?: return
        val b = getChildAtOrNull(indexB) ?: return
        swapChildren(a, b)
    }

    // @TODO: Optimize
    fun swapChildrenAt(indexA: Int, indexB: Int, count: Int) {
        repeat(count) { swapChildrenAt(indexA + it, indexB + it) }
    }

    // @TODO: Optimize
    fun moveChildrenAt(from: Int, to: Int, count: Int = 1) {
        val children = (0 until count).mapNotNull {
            getChildAtOrNull(from).also { removeChildAt(from) }
        }
        val finalTo = if (from < to) to - count else to
        children.fastForEach { child -> addChildAt(child, finalTo) }
        invalidateZIndexChildren()
    }

    /**
     * Removes all [View]s children from this container.
     */
    fun removeChildren() {
        fastForEachChild { child ->
            child.parent = null
            child.index = -1
        }
        __children.clear()
        invalidateZIndexChildren()
    }

    inline fun removeChildrenIf(cond: (index: Int, child: View) -> Boolean): Boolean {
        val children = this._children!! as FastArrayList<View>
        var removedCount = 0
        forEachChildWithIndex { index, child ->
            if (cond(index, child)) {
                child._parent = null
                child._index = -1
                removedCount++
            } else {
                child._index -= removedCount
                children[child._index] = child
            }
        }
        repeat(removedCount) { children.removeAt(children.size - 1) }
        invalidateZIndexChildren()
        return removedCount > 0
    }

    /**
     * Adds a child [View] to the container.
     *
     * If the [View] already belongs to a parent, it is removed from it and then added to the container.
     */
    fun addChild(view: View) = addChildAt(view, numChildren)

    /** Equivalent to [addChild] */
    operator fun <T : View> T.unaryPlus(): T {
        addChild(this)
        return this
    }

    // Use .apply { } instead
    //inline operator fun <T : View> T.invoke(block: T.() -> Unit): T {
    //    block(this)
    //    return this
    //}

    fun addChildren(views: List<View?>?) {
        if (views == null) return
        views.fastForEach { if (it != null) addChild(it) }
    }

    /**
     * Alias for [addChild].
     */
    operator fun plusAssign(view: View) {
        addChildAt(view, numChildren)
    }

    /** Alias for [getChildAt] */
    operator fun get(index: Int): View = getChildAt(index)

    /**
     * Alias for [removeChild].
     */
    operator fun minusAssign(view: View) {
        removeChild(view)
    }

    private val tempMatrix = MMatrix()
    override fun renderInternal(ctx: RenderContext) {
        if (!visible) return
        renderChildrenInternal(ctx)
    }

    open fun renderChildrenInternal(ctx: RenderContext) {
        //fastForEachChildRender { child: View ->
        //    child.render(ctx)
        //}
        if (!cull) {
            fastForEachChildRender { child: View ->
                child.render(ctx)
            }
            return
        }
        //currentVirtualRect.setBounds(ctx.virtualLeft, ctx.virtualTop, ctx.virtualRight, ctx.virtualBottom)
        val clippingContainer = findFirstAscendant { (it is FixedSizeContainer) && it.clip } as? FixedSizeContainer?

        //val bounds = this.getLocalBounds(Rectangle())
        var renderedCount = 0
        var culledCount = 0
        val bounds = clippingContainer?.getGlobalBounds() ?: Rectangle.NIL
        fastForEachChildRender { child: View ->
            //if (bounds.intersects(child.getLocalBoundsOptimized(includeFilters = true))) {
            if (bounds.isNIL || bounds.intersects(child.getGlobalBounds(includeFilters = true))) {
                child.render(ctx)
                renderedCount++
            } else {
                culledCount++
            }
        }
    }

    override fun renderDebug(ctx: RenderContext) {
        fastForEachChildRender { child: View ->
            child.renderDebug(ctx)
        }
        super.renderDebug(ctx)
    }

    override fun getLocalBoundsInternal(): Rectangle {
        var bb = BoundsBuilder()
        fastForEachChild { child: View ->
            bb += child.getBounds(this)
        }
        return bb.bounds
    }

    /**
     * Creates a new container.
     * @return an empty container.
     */
    override fun createInstance(): View = Container()

    /**
     * Performs a deep copy of the container, by copying all the child [View]s.
     */
    override fun clone(): View {
        val out = super.clone()
        fastForEachChild { out += it.clone() }
        return out
    }

    override fun findViewByName(name: String): View? {
        val result = super.findViewByName(name)
        if (result != null) return result
        fastForEachChild { child: View ->
            val named = child.findViewByName(name)
            if (named != null) return named
        }
        return null
    }

    object ZIndexComparator : Comparator<View> {
        override fun compare(a: View, b: View): Int = a.zIndex.compareTo(b.zIndex)
    }

    @PublishedApi internal var __childrenZIndexValid = false
    @PublishedApi internal var __childrenZIndexValidOrder = false
    @PublishedApi internal val __childrenZIndex = FastArrayList<View>()

    @PublishedApi internal fun shouldSortChildren(): Boolean {
        __children.fastForEach { if (it.zIndex != 0.0) { return true } }
        return false
    }

    /**
     * Iterates children in render order
     */
    // @TODO: Instead of resort everytime that something changes, let's keep an index in the zIndex collection
    inline fun fastForEachChildRender(block: (child: View) -> Unit) {
        if (!__childrenZIndexValid) {
            __childrenZIndexValid = true
            __childrenZIndex.clear()
            __childrenZIndex.addAll(this.children)
            if (shouldSortChildren()) __childrenZIndexValidOrder = false
            //println("fastForEachChildRender[$this] __childrenZIndex: ${__childrenZIndex.size}")
            //println("invalidated")
        }
        if (!__childrenZIndexValidOrder) {
            __childrenZIndexValidOrder = true
            __childrenZIndex.sortWith(ZIndexComparator)
        }
        //println(__childrenZIndex.map { it.zIndex })
        __childrenZIndex.fastForEach { child -> block(child) }
        //__children.fastForEach { child -> block(child) }
    }

    // @TODO: Instead of resort everytime that something changes, let's keep an index in the zIndex collection
    @PublishedApi internal fun invalidateZIndexChildren() {
        this.__childrenZIndexValid = false
        invalidateContainer()
    }

    // @TODO: Instead of resort everytime that something changes, let's keep an index in the zIndex collection
    @PublishedApi internal fun updatedChildZIndex(child: View, oldZIndex: Double, newZIndex: Double) {
        if (child.parent != this) return
        __childrenZIndexValidOrder = false
        invalidateContainer()
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Base methods that update the collection
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    protected fun invalidateContainer() {
        stage?.views?.invalidatedView(this)
    }


    internal fun checkValidChild(child: View) {
        val parent = this
        if (parent === child) invalidOp("Can't addChild to itself")
        if (parent.hasAncestor(child)) invalidOp("Can't addChild to an ancestor")
    }

    /**
     * Adds the [view] [View] as a child at a specific [index].
     *
     * Remarks: if [index] is outside bounds 0..[numChildren], it will be clamped to the nearest valid value.
     */
    fun addChildAt(view: View, index: Int) {
        checkValidChild(view)

        view.parent?.invalidateZIndexChildren()
        view.removeFromParent()
        val aindex = index.clamp(0, this.numChildren)
        view.index = aindex
        val children = __children
        children.add(aindex, view)
        for (n in aindex + 1 until children.size) children[n].index = n // Update other indices
        view.parent = this
        view.invalidate()
        onChildAdded(view)
        invalidateZIndexChildren()
        invalidateContainer()
        invalidateLocalBounds()
    }

    /**
     * Removes the specified [view] from this container.
     *
     * Returns true if the child was removed from this container.
     * Returns false, if nothing happened.
     *
     * Remarks: If the parent of [view] is not this container, this function doesn't do anything.
     */
    fun removeChild(view: View?): Boolean {
        //if (view == null) return false
        if (view?.parent !== this) return false
        for (i in view.index + 1 until numChildren) __children[i].index--
        __children.removeAt(view.index)
        view.parent = null
        view.index = -1
        invalidateZIndexChildren()
        invalidateContainer()
        invalidateLocalBounds()
        return true
    }

    /**
     * Replaces this child [old] with a [new] view.
     *
     * [old] must be part of this Container
     */
    fun replaceChild(old: View, new: View): Boolean {
        if (old === new) return false
        if (old.parent != this) return false

        invalidateContainer()
        invalidateZIndexChildren()
        new.parent?.__children?.remove(new)
        old.parent!!.__children[old.index] = new
        new.index = old.index
        new.parent = old.parent
        old.parent = null
        new.invalidate()
        old.index = -1
        invalidateLocalBounds()
        return true
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Event Listeners
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    override fun <T : BEvent> dispatchChildren(type: EventType<T>, event: T, result: EventResult?) {
        if (__tempDispatchChildren == null) __tempDispatchChildren = FastArrayList(children.size)
        __children.fastForEachWithTemp(__tempDispatchChildren!!) {
            it.dispatchDown(type, event, result)
        }
    }
}

/**
 * Allows to safely interact with the children of a [container] instance.
 */
class ContainerCollection internal constructor(val container: Container, children: List<View>) : MutableCollection<View>, List<View> by children {
    override val size: Int get() = container.numChildren

    override fun contains(element: View): Boolean = element.parent === container
    override fun containsAll(elements: Collection<View>): Boolean = elements.all { it.parent === container }
    override fun isEmpty(): Boolean = container.numChildren == 0

    override fun add(element: View): Boolean {
        container.addChild(element)
        return true
    }

    override fun addAll(elements: Collection<View>): Boolean {
        if (elements.isEmpty()) return false
        for (element in elements) container.addChild(element)
        return true
    }

    override fun clear() {
        container.removeChildren()
    }

    override fun iterator(): MutableIterator<View> = object : MutableIterator<View> {
        var index = 0
        override fun hasNext(): Boolean = (index < container.numChildren)
        override fun next(): View = container.getChildAt(index++)
        // @TODO: Cannot optimize because we need to move the rest of the children, and we might not complete the iteration
        override fun remove() { container.removeChildAt(--index) }
    }

    override fun remove(element: View): Boolean = container.removeChild(element)

    override fun removeAll(elements: Collection<View>): Boolean {
        val set = elements.toSet()
        return container.removeChildrenIf { _, view -> view in set }
    }

    override fun retainAll(elements: Collection<View>): Boolean {
        val set = elements.toSet()
        return container.removeChildrenIf { _, view -> view !in set }
    }
}

/** Alias for `parent += this`. Refer to [Container.plusAssign]. */
fun <T : View> T.addTo(parent: Container): T {
    parent += this
    return this
}

/** Adds the specified [view] to this view only if this view is a [Container]. */
operator fun View?.plusAssign(view: View?) {
    val container = this as? Container?
    if (view != null) container?.addChild(view)
}

inline fun <T : View> T.addTo(instance: Container, callback: @ViewDslMarker T.() -> Unit = {}) =
    this.addTo(instance).apply(callback)

inline fun <T : View> Container.append(view: T): T {
    addChild(view)
    return view
}

inline fun <T : View> Container.append(view: T, block: T.() -> Unit): T = append(view).also(block)

fun View.bringToTop() {
    val parent = this.parent ?: return
    parent.moveChildTo(this, parent.numChildren - 1)
}

fun View.bringToBottom() {
    val parent = this.parent ?: return
    parent.moveChildTo(this, 0)
}
